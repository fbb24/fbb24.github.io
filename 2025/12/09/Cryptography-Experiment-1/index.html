<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Cryptography-Experiment-1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="现代密码学实验一：基础加密与攻击分析   课程名称 现代密码学 实验人 冯汝鑫    题目 实验一：典型弱点分析与基础攻击方法 学号 23009200482   实验摘要本实验围绕现代密码学中的典型弱点分析与基础攻击方法展开。 首先，通过 Coursera Dan Boneh 课程的 Many Time Pad 编程作业，深入理解了一次性密钥（One-Time Pad）被重复使用在 XOR 加密中">
<meta property="og:type" content="article">
<meta property="og:title" content="Cryptography-Experiment-1">
<meta property="og:url" content="http://example.com/2025/12/09/Cryptography-Experiment-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="现代密码学实验一：基础加密与攻击分析   课程名称 现代密码学 实验人 冯汝鑫    题目 实验一：典型弱点分析与基础攻击方法 学号 23009200482   实验摘要本实验围绕现代密码学中的典型弱点分析与基础攻击方法展开。 首先，通过 Coursera Dan Boneh 课程的 Many Time Pad 编程作业，深入理解了一次性密钥（One-Time Pad）被重复使用在 XOR 加密中">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-09T12:57:50.000Z">
<meta property="article:modified_time" content="2025-12-09T19:45:38.895Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Cryptography-Experiment-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/09/Cryptography-Experiment-1/" class="article-date">
  <time class="dt-published" datetime="2025-12-09T12:57:50.000Z" itemprop="datePublished">2025-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Cryptography-Experiment-1
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="现代密码学实验一：基础加密与攻击分析"><a href="#现代密码学实验一：基础加密与攻击分析" class="headerlink" title="现代密码学实验一：基础加密与攻击分析"></a>现代密码学实验一：基础加密与攻击分析</h1><table>
<thead>
<tr>
<th align="left">课程名称</th>
<th align="left">现代密码学</th>
<th align="left">实验人</th>
<th align="left">冯汝鑫</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>题目</strong></td>
<td align="left"><strong>实验一：典型弱点分析与基础攻击方法</strong></td>
<td align="left"><strong>学号</strong></td>
<td align="left">23009200482</td>
</tr>
</tbody></table>
<h2 id="实验摘要"><a href="#实验摘要" class="headerlink" title="实验摘要"></a>实验摘要</h2><p>本实验围绕现代密码学中的典型弱点分析与基础攻击方法展开。</p>
<p>首先，通过 <strong>Coursera Dan Boneh</strong> 课程的 <strong>Many Time Pad</strong> 编程作业，深入理解了一次性密钥（One-Time Pad）被重复使用在 XOR 加密中带来的严重安全隐患，并利用统计学规律实现了对多条密文的明文恢复攻击。</p>
<p>随后，在 <strong>Cryptopals Set 1</strong> 的练习中，编写程序完成了从基础的编码转换（Hex&#x2F;Base64）到复杂的重复密钥 XOR 破解，掌握了汉明距离分析与 ECB 模式检测技巧。</p>
<p>最后，在 <strong>MTC3 (MysteryTwister C3)</strong> 挑战中，针对泄露的管理员 SHA1 哈希值，结合物理侧信道信息（键盘磨损&#x2F;指纹）和键盘布局特性，编写 Python 脚本通过受限字典排列组合成功还原了密码。</p>
<p>本实验综合展示了密码系统在不安全配置下的脆弱性。</p>
<hr>
<h2 id="一、-Coursera-Dan-Boneh-PA1-Many-Time-Pad-攻击"><a href="#一、-Coursera-Dan-Boneh-PA1-Many-Time-Pad-攻击" class="headerlink" title="一、 Coursera Dan Boneh &#x2F; PA1: Many Time Pad 攻击"></a>一、 Coursera Dan Boneh &#x2F; PA1: Many Time Pad 攻击</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><p>题目提供了一个由同一个流密码密钥加密得到的 10 个十六进制密文串。加密方式是逐字节异或（XOR）。目标是利用这 10 个已知的密文，推导出密钥（Key），并最终解密出第 11 个目标密文。</p>
<h3 id="1-2-理论分析"><a href="#1-2-理论分析" class="headerlink" title="1.2 理论分析"></a>1.2 理论分析</h3><p>已知消息 $M$ 和密钥 $K$，异或加密的过程为：<br>$$C &#x3D; M \oplus K$$</p>
<p>由于异或运算具有自反性，解密过程为：<br>$$M &#x3D; C \oplus K$$</p>
<p>当同一个密钥 $K$ 被用于加密两个不同的明文 $M_1$ 和 $M_2$ 得到密文 $C_1$ 和 $C_2$ 时，如果我们对两个密文进行异或：<br>$$B &#x3D; C_1 \oplus C_2 &#x3D; (M_1 \oplus K) \oplus (M_2 \oplus K) &#x3D; M_1 \oplus M_2$$</p>
<h3 id="1-3-攻击代码实现"><a href="#1-3-攻击代码实现" class="headerlink" title="1.3 攻击代码实现"></a>1.3 攻击代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">msg_1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0d0455468aeb98622b137dae857553ccd8883a7bc37520e06e515d22c954eba5025b8cc57ee59418ce7dc6bc41556bdb36bbca3e8774301fbcaa3b83b220809560987815f65286764703de0f3d524400a19b159610b11ef3e&#x27;</span>)</span><br><span class="line">msg_2 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde548b12b07df44ba7191d9606ef4081ffde5ad46a5069d9f7f543bedb9c861bf29c7e205132eda9382b0bc2c5c4b45f919cf3a9f1cb74151f6d551f4480c82b2cb24cc5b028aa76eb7b4ab24171ab3cdadb8356f&#x27;</span>)</span><br><span class="line">msg_3 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8ad40b62b07df44ba6e9d8a2368e51d04e0e7b207b70b9b8261112bacb6c866a232dfe257527dc29398f5f3251a0d47e503c66e935de81230b59b7afb5f41afa8d661cb&#x27;</span>)</span><br><span class="line">msg_4 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8ad5ea06a029056f47a8ad3306ef5021eafe1ac01a81197847a5c68a1b78769a37bc8f4575432c198ccb4ef63590256e305cd3a9544ee4160ead45aef520489e7da7d835402bca670bda8eb775200b8dabbba246b130f040d8ec6447e2c767f3d30ed81ea2e4c1404e1315a1010e7229be6636aaa&#x27;</span>)</span><br><span class="line">msg_5 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e24fe56808c213f17c81d9607cee021dafe1e001b21ade877a5e68bea88d61b93ac5ee0d562e8e9582f5ef375f0a4ae20ed86e935de81230b59b73fb4302cd95d770c65b40aaa065f2a5e33a5a0bb5dcaba43722130f042f8ec85b7c2070&#x27;</span>)</span><br><span class="line">msg_6 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde24eb76a19d84aba34d8de287be84d07e7e9a30ee714979c7e1123a8bd9822a33ecaf512472e8e8f8db3f9635c1949e640c621854eba0d79eccf52ff111284b4cc61d11902aebc66f2b2e436434eacc0aba938220b084800c2ca4e693522643573b2c4ce35050b0cf774201f0fe52ac9f26d71b6cf61a711cc229f77ace7aa88a2f19983122b11be87a59c355d25f8e4&#x27;</span>)</span><br><span class="line">msg_7 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6ea5ba47b01c909ba7696cf606ef40c04afe1ac0aa8148dd066592ded9f8774b529c7ea125d298e8883f5e9305f4b44f915cb2bd05af51373fd9b4af511039fa2d96f83414aaaf261bda2e97b170fb5cce2a53e675c154c0d9681596934777e2275b381ce2e40582afe67650b13e72287ff2270abcf73bb028932836fbdecfecee0a3b894473c1bbeb6b4913a536ce4f9b13f1efff71ea313c8661dd9a4ce&#x27;</span>)</span><br><span class="line">msg_8 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;315c4eeaa8b5f8bffd11155ea506b56041c6a00c8a08854dd21a4bbde54ce56801d943ba708b8a3574f40c00fff9e00fa1439fd0654327a3bfc860b92f89ee04132ecb9298f5fd2d5e4b45e40ecc3b9d59e9417df7c95bba410e9aa2ca24c5474da2f276baa3ac325918b2daada43d6712150441c2e04f6565517f317da9d3&#x27;</span>)</span><br><span class="line">msg_9 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;271946f9bbb2aeadec111841a81abc300ecaa01bd8069d5cc91005e9fe4aad6e04d513e96d99de2569bc5e50eeeca709b50a8a987f4264edb6896fb537d0a716132ddc938fb0f836480e06ed0fcd6e9759f40462f9cf57f4564186a2c1778f1543efa270bda5e933421cbe88a4a52222190f471e9bd15f652b653b7071aec59a2705081ffe72651d08f822c9ed6d76e48b63ab15d0208573a7eef027&#x27;</span>)</span><br><span class="line">msg_10 = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;466d06ece998b7a2fb1d464fed2ced7641ddaa3cc31c9941cf110abbf409ed39598005b3399ccfafb61d0315fca0a314be138a9f32503bedac8067f03adbf3575c3b8edc9ba7f537530541ab0f9f3cd04ff50d66f1d559ba520e89a2cb2a83&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg_target = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;32510ba9babebbbefd001547a810e67149caee11d945cd7fc81a05e9f85aac650e9052ba6a8cd8257bf14d13e6f0a803b54fde9e77472dbff89d71b57bddef121336cb85ccb8f3315f4b52e301d16e9f52f904&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msgs = [msg_1, msg_2, msg_3, msg_4, msg_5, msg_6, msg_7, msg_8, msg_9, msg_10]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytesxor</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 对两个字节序列进行逐位异或</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">bytes</span>([x ^ y <span class="keyword">for</span> (x, y) <span class="keyword">in</span> <span class="built_in">zip</span>(a[:<span class="built_in">len</span>(b)], b)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">bytes</span>([x ^ y <span class="keyword">for</span> (x, y) <span class="keyword">in</span> <span class="built_in">zip</span>(a, b[:<span class="built_in">len</span>(a)])])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isalpha</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="comment"># 判断是否为英文字母</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= b &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>)) <span class="keyword">or</span> (<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) &lt;= b &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line"></span><br><span class="line">key = [<span class="number">0</span>] * <span class="built_in">len</span>(msg_7)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, msg_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(msgs):</span><br><span class="line">    <span class="comment"># 计数数组：统计在位置 k 处，异或结果&quot;不是字母&quot;的次数</span></span><br><span class="line">    may_not_space = [<span class="number">0</span>] * <span class="built_in">len</span>(msg_i)</span><br><span class="line">    <span class="keyword">for</span> j, msg_j <span class="keyword">in</span> <span class="built_in">enumerate</span>(msgs):</span><br><span class="line">        <span class="keyword">if</span> i != j:</span><br><span class="line">            xored = bytesxor(msg_i, msg_j)</span><br><span class="line">            <span class="keyword">for</span> k, xb <span class="keyword">in</span> <span class="built_in">enumerate</span>(xored):</span><br><span class="line">                <span class="comment"># 如果异或结果不是字母且不是0（排除自身异或或完全相同字符），则该位置不太可能是空格</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> isalpha(xb)) <span class="keyword">and</span> xb != <span class="number">0</span>:</span><br><span class="line">                    may_not_space[k] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查计数结果，推断空格</span></span><br><span class="line">    <span class="keyword">for</span> j, count <span class="keyword">in</span> <span class="built_in">enumerate</span>(may_not_space):</span><br><span class="line">        <span class="comment"># 阈值设为2（允许少量的非字母标点符号出现）</span></span><br><span class="line">        <span class="keyword">if</span> count &lt;= <span class="number">2</span>: </span><br><span class="line">            <span class="comment"># 如果判定 msg_i[j] 是空格，则 Key[j] = msg_i[j] ^ ord(&#x27; &#x27;)</span></span><br><span class="line">            key_byte = msg_i[j] ^ <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 填入密钥</span></span><br><span class="line">            <span class="keyword">if</span> key[j] == <span class="number">0</span>:</span><br><span class="line">                key[j] = key_byte</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 简单的冲突检测：如果新计算的 key_byte 与已有 key 不一致，进行二次验证</span></span><br><span class="line">            <span class="keyword">if</span> key[j] != key_byte: </span><br><span class="line">                reliable = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> msgs:</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= <span class="built_in">len</span>(m): <span class="keyword">continue</span></span><br><span class="line">                    byte = m[j] ^ key_byte</span><br><span class="line">                    <span class="comment"># 验证还原出的明文是否大体是可打印字符</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isalpha(byte) <span class="keyword">and</span> byte != <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>):</span><br><span class="line">                        reliable = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> reliable:</span><br><span class="line">                    key[j] = key_byte</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Recovered key: <span class="subst">&#123;<span class="built_in">bytes</span>(key)&#125;</span>&#x27;</span>)</span><br><span class="line">decrypted_target = bytesxor(<span class="built_in">bytes</span>(key), msg_target)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Target message: <span class="subst">&#123;decrypted_target&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>实验结果：</strong><br>Target message: <code>The secret message is: When using a stream cipher, never use the key more than once</code></p>
<hr>
<h2 id="二、-Cryptopals-Set-1-基础与重复密钥-XOR-练习"><a href="#二、-Cryptopals-Set-1-基础与重复密钥-XOR-练习" class="headerlink" title="二、 Cryptopals Set 1: 基础与重复密钥 XOR 练习"></a>二、 Cryptopals Set 1: 基础与重复密钥 XOR 练习</h2><p>本部分实验主要在 Cryptopals 平台进行，旨在通过一系列编程挑战，由浅入深地掌握现代密码学中的编码、异或运算、统计分析及分组密码模式识别 。</p>
<h3 id="2-1-将十六进制转换为-Base64-Convert-hex-to-base64"><a href="#2-1-将十六进制转换为-Base64-Convert-hex-to-base64" class="headerlink" title="2.1 将十六进制转换为 Base64 (Convert hex to base64)"></a>2.1 将十六进制转换为 Base64 (Convert hex to base64)</h3><p><strong>题目描述：</strong> 将给定的十六进制字符串转换为 Base64 编码字符串。这是网络传输和加密数据存储中非常基础的操作。</p>
<p><strong>代码实现：</strong><br>利用 Python 标准库 <code>base64</code> 进行转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"></span><br><span class="line">hex_str = <span class="string">&#x27;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&#x27;</span></span><br><span class="line"><span class="comment"># 先将 hex 转换为 bytes，再进行 b64 编码</span></span><br><span class="line"><span class="built_in">print</span>(b64encode(<span class="built_in">bytes</span>.fromhex(hex_str)).decode())</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-固定异或-Fixed-XOR"><a href="#2-2-固定异或-Fixed-XOR" class="headerlink" title="2.2 固定异或 (Fixed XOR)"></a>2.2 固定异或 (Fixed XOR)</h3><p><strong>题目描述：</strong> 编写一个函数，输入两个等长的缓冲区，返回它们逐字节异或（XOR）的结果 。</p>
<p><strong>理论分析：</strong><br>异或运算（$\oplus$）是大多数对称加密算法（如流密码、AES）的核心组件。其真值表特性为：相同为 0，不同为 1。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bytesxor</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 确保处理长度对齐（取较短长度）</span></span><br><span class="line">    length = <span class="built_in">min</span>(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([x ^ y <span class="keyword">for</span> (x, y) <span class="keyword">in</span> <span class="built_in">zip</span>(a[:length], b[:length])])</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;1c0111001f010100061a024b53535009181c&#x27;</span>)</span><br><span class="line">b = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;686974207468652062756c6c277320657965&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bytesxor(a, b).<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-单字节异或密码破解-Single-byte-XOR-cipher"><a href="#2-3-单字节异或密码破解-Single-byte-XOR-cipher" class="headerlink" title="2.3 单字节异或密码破解 (Single-byte XOR cipher)"></a>2.3 单字节异或密码破解 (Single-byte XOR cipher)</h3><p><strong>题目描述：</strong> 给定一个被单字节密钥（Key 为 0-255 之间的某个值）异或加密的密文，找出明文。</p>
<p><strong>破解思路：</strong><br>由于密钥空间极小（仅 256 种可能），我们可以采用<strong>暴力枚举（Brute-force）</strong>。核心难点在于如何判断解密结果是否为“正确”的英文文本。为此，我设计了一个基于英文字符频率和特定规则的<strong>评分函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于字符特征和英文规则的评分算法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 常用三字词库 (Trigrams)</span></span><br><span class="line">    common_trigrams = <span class="built_in">set</span>(<span class="string">&quot;the and tha ent ing ion...&quot;</span>.split()) </span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 规则1: 句子结尾有标点加分</span></span><br><span class="line">    <span class="keyword">if</span> message <span class="keyword">and</span> message[-<span class="number">1</span>] <span class="keyword">in</span> <span class="string">&#x27;.?!&#x27;</span>: s += <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 规则2: 统计常用三字词</span></span><br><span class="line">    words = message.split()</span><br><span class="line">    s += <span class="built_in">sum</span>(<span class="number">3</span> <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> <span class="built_in">len</span>(w) &gt;= <span class="number">3</span> <span class="keyword">and</span> w[:<span class="number">3</span>].lower() <span class="keyword">in</span> common_trigrams)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 规则3: 惩罚非打印字符或异常符号</span></span><br><span class="line">    <span class="comment"># (完整逻辑见源码，此处省略细节)</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">cipher = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&#x27;</span>)</span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有可能的密钥 (0-255)</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 生成对应长度的密钥流并异或</span></span><br><span class="line">        decoded = bytesxor((<span class="built_in">chr</span>(k) * <span class="built_in">len</span>(cipher)).encode(), cipher).decode()</span><br><span class="line">        results.append((decoded, get_score(decoded)))</span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取得分最高的结果</span></span><br><span class="line">best_result = <span class="built_in">sorted</span>(results, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted: <span class="subst">&#123;best_result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>实验结果：</strong> 解密得到 <em>“Cooking MC’s like a pound of bacon”</em>。</p>
<hr>
<h3 id="2-4-检测单字符异或-Detect-single-character-XOR"><a href="#2-4-检测单字符异或-Detect-single-character-XOR" class="headerlink" title="2.4 检测单字符异或 (Detect single-character XOR)"></a>2.4 检测单字符异或 (Detect single-character XOR)</h3><p><strong>题目描述：</strong> 文件中包含 60 字节长的 327 行字符串，其中只有一行是被单字符异或加密的。找出这一行并解密 。</p>
<p><strong>实现方法：</strong><br>复用 2.3 中的逻辑，对文件中的每一行都进行 256 次暴力尝试，并计算最高得分。最终对比所有行的最高得分，分值最高的即为目标行。</p>
<p><strong>实验结果：</strong></p>
<ul>
<li><strong>密文行：</strong> <code>7b5a4215415d544115415d5015455447414c155c46155f4058455c5b523f</code></li>
<li><strong>解密结果：</strong> <code>Now that the party is jumping</code></li>
</ul>
<hr>
<h3 id="2-5-实现重复密钥异或-Implement-repeating-key-XOR"><a href="#2-5-实现重复密钥异或-Implement-repeating-key-XOR" class="headerlink" title="2.5 实现重复密钥异或 (Implement repeating-key XOR)"></a>2.5 实现重复密钥异或 (Implement repeating-key XOR)</h3><p><strong>题目描述：</strong> 使用密钥 “ICE” 对明文进行重复密钥异或加密（。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeating_key_xor_to_hex</span>(<span class="params">msg: <span class="built_in">bytes</span>, key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 使用取模运算循环使用密钥</span></span><br><span class="line">    encrypted = <span class="built_in">bytes</span>([b ^ key[i % <span class="built_in">len</span>(key)] <span class="keyword">for</span> i, b <span class="keyword">in</span> <span class="built_in">enumerate</span>(msg)])</span><br><span class="line">    <span class="keyword">return</span> encrypted.<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">plaintext = <span class="string">b&quot;Burning &#x27;em, if you ain&#x27;t quick and nimble&quot;</span></span><br><span class="line">key = <span class="string">b&quot;ICE&quot;</span></span><br><span class="line"><span class="built_in">print</span>(repeating_key_xor_to_hex(plaintext, key))</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-破解重复密钥异或-Break-repeating-key-XOR"><a href="#2-6-破解重复密钥异或-Break-repeating-key-XOR" class="headerlink" title="2.6 破解重复密钥异或 (Break repeating-key XOR)"></a>2.6 破解重复密钥异或 (Break repeating-key XOR)</h3><p><strong>题目描述：</strong> 给定一个被重复密钥异或加密的 Base64 文件，在不知道密钥长度的情况下还原密钥和明文。</p>
<p><strong>攻击步骤与理论：</strong></p>
<ol>
<li><p><strong>推测密钥长度 (Guess Key Size)</strong>：<br>利用<strong>汉明距离 (Hamming Distance)</strong>。汉明距离是指两个字符串对应位置不同的二进制位的个数。<br>$$Hamming(s_1, s_2) &#x3D; CountSetBits(s_1 \oplus s_2)$$<br>理论上，正确密钥长度（或其倍数）下的密文块之间的归一化汉明距离（Distance &#x2F; KeySize）是最小的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 汉明距离计算示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalized_average_hd</span>(<span class="params">data: <span class="built_in">bytes</span>, unit_len: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="comment"># 将数据切分为 unit_len 长度的块，计算块之间的平均比特差异</span></span><br><span class="line">    <span class="comment"># ... (代码省略)</span></span><br><span class="line">    <span class="keyword">return</span> total_hd / (count * unit_len)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>密文转置 (Transpose)</strong>：<br>假设猜测的密钥长度为 $L$。将密文分为 $L$ 组：</p>
<ul>
<li>第 1 组包含索引为 $0, L, 2L, \dots$ 的字节</li>
<li>第 2 组包含索引为 $1, L+1, 2L+1, \dots$ 的字节</li>
<li>…<br>每一组内的字节实际上都是由密钥的<strong>同一个字符</strong>进行异或加密的。</li>
</ul>
</li>
<li><p><strong>单字节破解 (Solve Single-byte XOR)</strong>：<br>现在的每个分组就是一个“单字节异或密码”问题。利用 2.3 节的评分函数，分别破解出这 $L$ 个分组对应的单字节密钥。</p>
</li>
<li><p><strong>重组密钥 (Reconstruct Key)</strong>：<br>将 $L$ 个单字节密钥按顺序组合，得到完整的重复密钥。</p>
</li>
</ol>
<p><strong>实验修正：</strong><br>在初次尝试时，评分函数未考虑到解密文中出现 <code>#</code> 的情况，导致评分偏差。通过调整评分逻辑（如 <code>if c == &#39;#&#39;: score -= 5</code>），成功提升了准确率。</p>
<p><strong>实验结果：</strong></p>
<ul>
<li><strong>推测密钥长度：</strong></li>
<li><strong>还原密钥：</strong> <code>Terminator X: Bring the noise</code></li>
</ul>
<hr>
<h3 id="2-7-2-8-AES-ECB-模式解密与检测"><a href="#2-7-2-8-AES-ECB-模式解密与检测" class="headerlink" title="2.7 &amp; 2.8 AES ECB 模式解密与检测"></a>2.7 &amp; 2.8 AES ECB 模式解密与检测</h3><p><strong>题目描述：</strong><br>7.  使用 AES-128 在 ECB 模式下解密文件。<br>8.  在大量密文中检测哪一行使用了 ECB 模式。</p>
<p><strong>理论分析：</strong><br><strong>ECB (Electronic Codebook)</strong> 模式是最简单的 AES 工作模式。其特点是：<strong>相同的明文块总是被加密成相同的密文块</strong>。这导致它无法隐藏数据的模式特征，是不安全的。</p>
<p><strong>代码实现 (检测 ECB)：</strong><br>检查密文中是否有重复的 16 字节块（Block）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.8 检测代码核心逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_ecb</span>(<span class="params">ciphertext_hex</span>):</span><br><span class="line">    <span class="comment"># 将密文按 16 字节 (32 hex chars) 分块</span></span><br><span class="line">    blocks = [ciphertext_hex[i:i+<span class="number">32</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ciphertext_hex), <span class="number">32</span>)]</span><br><span class="line">    <span class="comment"># 如果 块的总数 &gt; 唯一块的数量，说明有重复块 -&gt; 极大概率是 ECB</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(blocks) - <span class="built_in">len</span>(<span class="built_in">set</span>(blocks)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件并找出重复块最多的一行</span></span><br><span class="line">best_candidate = <span class="built_in">max</span>(<span class="built_in">open</span>(<span class="string">&#x27;8.txt&#x27;</span>).read().splitlines(), key=detect_ecb)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Detected ECB Ciphertext: <span class="subst">&#123;best_candidate&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="三、-MTC3-Cracking-SHA1-Hashed-Passwords"><a href="#三、-MTC3-Cracking-SHA1-Hashed-Passwords" class="headerlink" title="三、 MTC3: Cracking SHA1 Hashed Passwords"></a>三、 MTC3: Cracking SHA1 Hashed Passwords</h2><h3 id="3-1-题目背景"><a href="#3-1-题目背景" class="headerlink" title="3.1 题目背景"></a>3.1 题目背景</h3><p>根据提供的实验材料，本题模拟了一个监控系统管理员密码泄露的场景。</p>
<ul>
<li><strong>已知信息</strong>：泄露的 SHA1 哈希值为 <code>67ae1a64661ac8b4494666f58c4822408dd0a3e4</code> 。</li>
<li><strong>侧信道线索</strong>：提供了一张登录终端键盘的照片，显示键盘上有明显的使用痕迹。</li>
</ul>
<h3 id="3-2-线索分析"><a href="#3-2-线索分析" class="headerlink" title="3.2 线索分析"></a>3.2 线索分析</h3><p>观察提供的键盘图片，我们可以提取出以下关键信息：</p>
<ol>
<li><strong>被按下的按键（有绿色指纹标记）</strong>：<ul>
<li>字母键：<code>Q</code>, <code>W</code>, <code>I</code></li>
<li>数字键：<code>5</code>, <code>8</code>, <code>0</code></li>
<li>符号&#x2F;功能键：<code>Shift</code> (左右两侧), <code>+</code> (或 <code>*</code>), <code>Enter</code></li>
</ul>
</li>
<li><strong>密码构成推测</strong>：<ul>
<li>由于 <code>Shift</code> 键有明显痕迹，密码中很可能包含大写字母 <code>Q, W, I</code> 或特殊符号 <code>%, (, =, *</code>。</li>
<li>密码由这些被磨损按键的字符排列组合而成。</li>
</ul>
</li>
</ol>
<h3 id="3-3-攻击代码实现"><a href="#3-3-攻击代码实现" class="headerlink" title="3.3 攻击代码实现"></a>3.3 攻击代码实现</h3><p>不同于通用的字典攻击，这里我们使用<strong>基于字符集的排列攻击（Permutation Attack）</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment"># 题目给出的目标哈希 </span></span><br><span class="line">target_hash = <span class="string">&quot;67ae1a64661ac8b4494666f58c4822408dd0a3e4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于键盘指纹分析出的候选字符集 </span></span><br><span class="line"><span class="comment"># 包含：小写字母, 大写字母(因为有Shift), 数字, 以及德语键盘对应的特殊符号</span></span><br><span class="line"><span class="comment"># 注意：Q, W, I, 5, 8, 0, +, * (Shift+plus), % (Shift+5), ( (Shift+8), = (Shift+0)</span></span><br><span class="line">chars = [</span><br><span class="line">    <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;i&#x27;</span>,       <span class="comment"># 字母键</span></span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;0&#x27;</span>,                      <span class="comment"># 数字键</span></span><br><span class="line">    <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;=&#x27;</span>,                 <span class="comment"># Shift+数字 (德语布局可能产生的符号)</span></span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;*&#x27;</span>                            <span class="comment"># 符号键</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_mtc3</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始生成排列组合并计算哈希...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 假设密码长度在 4 到 8 位之间 (常见密码长度)</span></span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">9</span>):</span><br><span class="line">        <span class="comment"># 生成所有可能的字符排列</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> product(chars, repeat=length):</span><br><span class="line">            password = <span class="string">&quot;&quot;</span>.join(p)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算 SHA1</span></span><br><span class="line">            sha1_hash = hashlib.sha1(password.encode()).hexdigest()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sha1_hash == target_hash:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;\n[SUCCESS] 密码已找到!&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Hash: <span class="subst">&#123;sha1_hash&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Password: <span class="subst">&#123;password&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n[FAILED] 在当前字符集和长度范围内未找到密码。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    crack_mtc3()</span><br></pre></td></tr></table></figure>

<h3 id="3-4-实验结果分析"><a href="#3-4-实验结果分析" class="headerlink" title="3.4 实验结果分析"></a>3.4 实验结果分析</h3><p>运行脚本后，如果字符集构建正确，程序将输出破解后的密码。</p>
<p>通过此实验，我深刻理解了物理安全与逻辑安全的关系。即使使用了 SHA1 这样被认为是安全的哈希算法，如果攻击者能够接触到物理终端并提取指纹痕迹（Smudge Attack），密码的搜索空间将从 $95^N$ 急剧缩小到 $10^N$ 甚至更小，从而被轻易破解。</p>
<hr>
<h2 id="四、-实验总结"><a href="#四、-实验总结" class="headerlink" title="四、 实验总结"></a>四、 实验总结</h2><p>本次实验涵盖了流密码破解、块密码模式分析以及基于侧信道的哈希破解三个维度，主要心得如下：</p>
<ol>
<li><strong>密钥重用的危害性</strong>：Many Time Pad 实验证明，流密码密钥一旦重用，攻击者仅需密文统计即可还原明文，完全绕过密钥长度带来的安全性。</li>
<li><strong>物理泄露辅助密码分析</strong>：在 MTC3 实验中，单纯暴力破解 SHA1 是不可行的，但结合“键盘指纹”这一物理层面的侧信道信息，我们将攻击复杂度降低到了可接受的范围内。这提示我们在输入密码时应注意防止物理痕迹残留，或使用动态键盘布局。</li>
<li><strong>算法与实现的结合</strong>：从 Python 的 <code>itertools</code> 到 <code>hashlib</code> 的使用，本次实验锻炼了将数学原理转化为自动化攻击脚本的能力。</li>
</ol>
<hr>
<h2 id="五、-参考文献"><a href="#五、-参考文献" class="headerlink" title="五、 参考文献"></a>五、 参考文献</h2><ol>
<li><strong>Coursera Cryptography I</strong>: <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/crypto">https://www.coursera.org/learn/crypto</a></li>
<li><strong>Cryptopals Crypto Challenges</strong>: <a target="_blank" rel="noopener" href="http://www.cryptopals.com/sets/1">http://www.cryptopals.com/sets/1</a></li>
<li><strong>MysteryTwister C3 - Cracking SHA1-hashed passwords</strong>: PDF Source, Author: Chair for Cryptology and IT-Security.</li>
<li><strong>Python Documentation</strong>: <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/hashlib.html">https://docs.python.org/3/library/hashlib.html</a></li>
</ol>
<span id="more"></span>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/09/Cryptography-Experiment-1/" data-id="cuidV98OMthgZKKJ85ZAJsOKp" data-title="Cryptography-Experiment-1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/12/09/Cryptography-Experiment-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Cryptography-Experiment-2</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/09/Cryptography-Experiment-1/">Cryptography-Experiment-1</a>
          </li>
        
          <li>
            <a href="/2025/12/09/Cryptography-Experiment-2/">Cryptography-Experiment-2</a>
          </li>
        
          <li>
            <a href="/2025/12/09/Cryptography-Experiment-3/">Cryptography-Experiment-3</a>
          </li>
        
          <li>
            <a href="/2025/12/09/Cryptography-Experiment-4/">Cryptography-Experiment-4</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>